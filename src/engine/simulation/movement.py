"""Smooth movement controller for simulation units.

Handles waypoint-following with speed modulation, turn smoothing,
and basic collision avoidance. Units move along paths generated by
the A* pathfinder rather than teleporting between points.
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field


@dataclass
class MovementController:
    """Per-unit movement controller."""
    max_speed: float = 2.0
    turn_rate: float = 180.0  # degrees per second
    acceleration: float = 4.0  # m/s^2
    deceleration: float = 6.0  # m/s^2

    # Current state
    x: float = 0.0
    y: float = 0.0
    heading: float = 0.0  # degrees
    speed: float = 0.0

    # Path following
    _waypoints: list[tuple[float, float]] = field(default_factory=list)
    _waypoint_index: int = 0
    _patrol_loop: bool = False

    # Status
    arrived: bool = True

    def set_path(self, waypoints: list[tuple[float, float]], loop: bool = False) -> None:
        """Set a new path to follow."""
        self._waypoints = list(waypoints)
        self._waypoint_index = 0
        self._patrol_loop = loop
        self.arrived = len(waypoints) == 0

    def set_destination(self, x: float, y: float) -> None:
        """Simple: move to a single point."""
        self.set_path([(x, y)])

    def stop(self) -> None:
        """Stop movement, clear path."""
        self._waypoints.clear()
        self._waypoint_index = 0
        self.arrived = True

    def tick(self, dt: float) -> None:
        """Advance movement by dt seconds.

        1. Look at current waypoint target
        2. Calculate desired heading
        3. Turn toward target (limited by turn_rate)
        4. Accelerate/decelerate based on:
           - Distance to next waypoint
           - Angle difference (slow down for sharp turns)
        5. Move forward at current speed
        6. Check if arrived at waypoint, advance to next
        """
        if self.arrived or not self._waypoints:
            # Decelerate to stop
            self.speed = max(0.0, self.speed - self.deceleration * dt)
            return

        target = self._waypoints[self._waypoint_index]
        dx = target[0] - self.x
        dy = target[1] - self.y
        dist = math.sqrt(dx * dx + dy * dy)

        # Arrived at waypoint?
        if dist < 0.5:  # 0.5m threshold
            self._waypoint_index += 1
            if self._waypoint_index >= len(self._waypoints):
                if self._patrol_loop:
                    self._waypoint_index = 0
                else:
                    self.arrived = True
                    self.speed = 0.0
                    return
            return  # Process next waypoint on next tick

        # Desired heading
        desired_heading = math.degrees(math.atan2(dy, dx))

        # Turn toward target (limited by turn_rate)
        heading_diff = _angle_diff(self.heading, desired_heading)
        max_turn = self.turn_rate * dt
        if abs(heading_diff) <= max_turn:
            self.heading = desired_heading
        else:
            self.heading += max_turn * (1 if heading_diff > 0 else -1)
        self.heading = self.heading % 360

        # Speed modulation
        # Slow down for sharp turns
        turn_factor = 1.0 - min(abs(heading_diff) / 90.0, 0.8)
        # Slow down approaching waypoint (brake within 2m, floor at 10% max speed)
        approach_factor = max(min(dist / 2.0, 1.0), 0.1)

        desired_speed = self.max_speed * turn_factor * approach_factor

        # Accelerate/decelerate toward desired speed
        if self.speed < desired_speed:
            self.speed = min(self.speed + self.acceleration * dt, desired_speed)
        else:
            self.speed = max(self.speed - self.deceleration * dt, desired_speed)

        # Move — clamp step to remaining distance to prevent overshoot
        step = self.speed * dt
        if step >= dist:
            # Would overshoot — snap to waypoint
            self.x = target[0]
            self.y = target[1]
        else:
            rad = math.radians(self.heading)
            self.x += math.cos(rad) * step
            self.y += math.sin(rad) * step

    @property
    def current_waypoint(self) -> tuple[float, float] | None:
        if self._waypoints and self._waypoint_index < len(self._waypoints):
            return self._waypoints[self._waypoint_index]
        return None

    @property
    def remaining_waypoints(self) -> int:
        if not self._waypoints:
            return 0
        return max(0, len(self._waypoints) - self._waypoint_index)


def _angle_diff(a: float, b: float) -> float:
    """Shortest signed angle difference from a to b, in degrees."""
    diff = (b - a) % 360
    if diff > 180:
        diff -= 360
    return diff


def smooth_path(waypoints: list[tuple[float, float]], tolerance: float = 0.5) -> list[tuple[float, float]]:
    """Remove collinear waypoints within tolerance.

    Simplifies paths by removing points that are nearly on a straight
    line between their neighbors (Douglas-Peucker-like).
    """
    if len(waypoints) <= 2:
        return list(waypoints)

    result = [waypoints[0]]
    for i in range(1, len(waypoints) - 1):
        # Check if point i is collinear with result[-1] and waypoints[i+1]
        p0 = result[-1]
        p1 = waypoints[i]
        p2 = waypoints[i + 1]
        # Cross product magnitude = distance from line
        cross = abs((p2[0] - p0[0]) * (p1[1] - p0[1]) - (p1[0] - p0[0]) * (p2[1] - p0[1]))
        seg_len = math.sqrt((p2[0] - p0[0]) ** 2 + (p2[1] - p0[1]) ** 2)
        dist = cross / seg_len if seg_len > 0 else 0
        if dist > tolerance:
            result.append(p1)
    result.append(waypoints[-1])
    return result
